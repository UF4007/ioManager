# ioManager 内存模型说明

本文件图形化说明 ioManager 各核心类型的内存模型，便于理解其资源归属、指针关系和生命周期。

---

## 1. future/promise 对

**future/future_with<T> 所在协程栈帧中：**

```
┌─────────────────────────────
│ future / future_with<T> 对象
│ ├─ 指向等待体的指针
│ └─ T类型的对象
│      └─ (若为future_with<T>)
└─────────────────────────────
```

**promise<T> 所在协程栈帧中：**

```
┌─────────────────────────────
│ promise<T>对象
│ ├─ 指向等待体的指针
│ └─ 指向T的指针
│      └─ (若T不为void)
│      └─ 若与之绑定的future已析构，此指针将获取为nullptr
└─────────────────────────────
```

- 若future已析构，promise的T指针会失效（nullptr），防止悬挂指针。因此，强烈建议在future端保证future对象的析构时间，比T对象所在内存失效的时间早。

**manager中（全局/线程级）：**

```
┌─────────────────────────────
│ 等待体对象池
│ ├─ 存放所有等待体对象
│ └─ 每一个future-promise对，指向同一个等待体；一个等待体只能被一个future和一个promise指向。
└─────────────────────────────
```

---

## 2. async_future / async_promise 对

**async_future 协程栈帧中：**

```
┌─────────────────────────────
│ async_future对象：等价于future。
└─────────────────────────────
```

**外部 async_promise 持有者：**

```
┌─────────────────────────────
│ async_promise对象
│ └─ 指向等待体的原子指针
|    └─ 此对象的析构、完成操作，皆通过原子操作送入io::manager的异步线程析构、完成队列中进行。
└─────────────────────────────
```

**manager中（全局/线程级）：**

```
┌─────────────────────────────
│ 等待体对象池
│ ├─ 存放所有等待体对象
│ └─ 每一对async_future-async_promise指向同一个等待体
│ └─ 设有async_promise的操作队列，与协程调度器在同一线程执行
└─────────────────────────────
```

---

## 3. chan

**chan 协程栈帧中：**

```
┌─────────────────────────────
│ chan<T>对象
│ └─ 指向chan_base的智能指针
└─────────────────────────────
```

- chan_base对象在chan创建时分配，缓冲区内存一次性分配，所有数据收发都在这块内存上进行。但是等待队列会涉及动态内存分配。

**chan_base（堆上）：**

```
┌─────────────────────────────
│ chan_base对象
│ ├─ 环形缓冲区（循环队列，预分配内存）
│ ├─ 等待队列（std::deque，存放等待读取/写入的promise）
│ ├─ 状态标志（是否关闭、容量、当前大小等）
│ └─ 指向manager的指针
└─────────────────────────────
```

---

## 4. async_chan

**async_chan 持有者：**

```
┌─────────────────────────────
│ async_chan<T>对象
│ └─ 指向async_chan::chan_base的智能指针
└─────────────────────────────
```

- chan_base对象在async_chan创建时分配，创建时不分配缓冲区内存。

**async_chan::chan_base（堆上）：**

```
┌─────────────────────────────
│ async_chan::chan_base对象
│ ├─ segment链表（每个segment动态分配内存，存放数据块）
│ ├─ 等待队列（std::deque，存放async_promise）
│ ├─ 状态标志（是否关闭、容量、当前大小等）
│ └─ 自旋锁（std::atomic_flag，保护临界区）
└─────────────────────────────
```

- segment对象每次发送/接收数据时动态分配，数据消费后自动释放。
- 等待队列和segment链表处于自旋锁保护之下。

---

## 5. 管线

**pipeline_started对象：**

- 若通过 `std::move(pipeline).start()` 生成：

```
┌─────────────────────────────
│ pipeline_started对象
│ ├─ 持有各个环节（协议/适配器）的引用（左值创建）或对象（右值创建）
| └─ 每个管线段：
│     └─ 出协议所需的future_with<T>对象
│         └─ T的内存空间将暂存出协议收到的数据
│     └─ 入协议返回的future对象
└─────────────────────────────
```

- 若通过 `std::move(pipeline).spawn()` 生成：

```
┌─────────────────────────────
│ fsm_handle<void>（等同于一个协程句柄）
└─────────────────────────────
```

**协议对象：**

```
┌─────────────────────────────
│ 协议对象
│ ├─ 遵从出/入协议约定，保持内部状态
│ └─ 必须与管线运行的协程使用同一个manager，否则future-promise对无法正确生成
└─────────────────────────────
```
