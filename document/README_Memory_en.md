# ioManager Memory Model Explanation

This document graphically illustrates the memory models of core types in ioManager, making it easier to understand resource ownership, pointer relationships, and lifecycles.

---

## 1. future/promise Pair

**future/future_with<T> in coroutine stack frame:**

```
┌─────────────────────────────
│ future / future_with<T> object
│ ├─ Pointer to awaiter
│ └─ T object
│      └─ (if future_with<T>)
└─────────────────────────────
```

**promise<T> in coroutine stack frame:**

```
┌─────────────────────────────
│ promise<T> object
│ ├─ Pointer to awaiter
│ └─ Pointer to T
│      └─ (if T is not void)
│      └─ If the associated future is destroyed, this pointer becomes nullptr
└─────────────────────────────
```

- If the future is destroyed, the T pointer in promise becomes nullptr to prevent dangling pointers. Therefore, it is strongly recommended to ensure that the destruction time of the future object is earlier than the time when the memory where the T object resides becomes invalid.

**In manager (global/thread-level):**

```
┌─────────────────────────────
│ Awaiter object pool
│ ├─ Stores all awaiter objects
│ └─ Each future-promise pair points to the same awaiter; one awaiter can only be pointed to by one future and one promise.
└─────────────────────────────
```

---

## 2. async_future / async_promise Pair

**async_future in coroutine stack frame:**

```
┌─────────────────────────────
│ async_future object: equivalent to future.
└─────────────────────────────
```

**External async_promise holder:**

```
┌─────────────────────────────
│ async_promise object
│ └─ Atomic pointer to awaiter
|    └─ The destruction and completion operations of this object are all sent to the async thread destruction/completion queue of io::manager via atomic operations.
└─────────────────────────────
```

**In manager (global/thread-level):**

```
┌─────────────────────────────
│ Awaiter object pool
│ ├─ Stores all awaiter objects
│ └─ Each async_future-async_promise pair points to the same awaiter
│ └─ There is an operation queue for async_promise, executed in the same thread as the coroutine scheduler
└─────────────────────────────
```

---

## 3. chan

**chan in coroutine stack frame:**

```
┌─────────────────────────────
│ chan<T> object
│ └─ Smart pointer to chan_base
└─────────────────────────────
```

- The chan_base object is allocated when chan is created, and the buffer memory is allocated once. All data sending and receiving are performed on this memory. However, the wait queue involves dynamic memory allocation.

**chan_base (on heap):**

```
┌─────────────────────────────
│ chan_base object
│ ├─ Circular buffer (ring queue, pre-allocated memory)
│ ├─ Wait queue (std::deque, stores promises waiting to read/write)
│ ├─ State flags (closed, capacity, current size, etc.)
│ └─ Pointer to manager
└─────────────────────────────
```

---

## 4. async_chan

**async_chan holder:**

```
┌─────────────────────────────
│ async_chan<T> object
│ └─ Smart pointer to async_chan::chan_base
└─────────────────────────────
```

- The chan_base object is allocated when async_chan is created, and the buffer memory is not allocated at creation.

**async_chan::chan_base (on heap):**

```
┌─────────────────────────────
│ async_chan::chan_base object
│ ├─ Segment linked list (each segment dynamically allocates memory to store data blocks)
│ ├─ Wait queue (std::deque, stores async_promise)
│ ├─ State flags (closed, capacity, current size, etc.)
│ └─ Spinlock (std::atomic_flag, protects critical section)
└─────────────────────────────
```

- Segment objects are dynamically allocated each time data is sent/received and are automatically released after data is consumed.
- The wait queue and segment list are protected by the spinlock.

---

## 5. Pipeline

**pipeline_started object:**

- If generated by `std::move(pipeline).start()`,

```
┌─────────────────────────────
│ pipeline_started object
│ ├─ Holds references (lvalue creation) or objects (rvalue creation) of each stage (protocol/adapter)
| └─ Each pipeline segment:
│     └─ Output protocol's future_with<T> object
│         └─ T's memory temporarily stores data received from the output protocol
│     └─ Input protocol returns a future object
└─────────────────────────────
```

- If generated by `std::move(pipeline).spawn()`,

```
┌─────────────────────────────
│ fsm_handle<void> (equivalent to a coroutine handle)
└─────────────────────────────
```

**Protocol object:**

```
┌─────────────────────────────
│ Protocol object
│ ├─ Follows output/input protocol conventions, maintains internal state
│ └─ Must use the same manager as the coroutine running the pipeline, otherwise future-promise pairs cannot be created correctly
└─────────────────────────────
``` 